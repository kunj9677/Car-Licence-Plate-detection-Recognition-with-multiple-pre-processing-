# -*- coding: utf-8 -*-
"""Gaussian noise_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ybSP5QWYchFwgPtpG81Ku6daVNS10vdw
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
import os
from glob import glob
import cv2
from sklearn.model_selection import train_test_split



print(f'{torch.cuda.is_available() = }')
print(f'{torch.cuda.device_count() = }')

!pip install ultralytics

# connext to archive folder in drive
from google.colab import drive
drive.mount('/content/drive')
#https://drive.google.com/drive/folders/1_cack_LaBZwMP5SsSvG_f9y7xzKmeTlo?usp=share_link

# Adding Gaussian noise to an image
def add_gaussian_noise(image, mean=0, std=25):
    """ Add Gaussian noise to an image. """
    noise = np.random.normal(mean, std, image.shape).astype(np.float32)
    noisy_image = cv2.addWeighted(image.astype(np.float32), 1.0, noise, 1.0, 0)
    return np.clip(noisy_image, 0, 255).astype(np.uint8)

#dataset_path = 'archive'
dataset_path = '/content/drive/MyDrive/archive'

import re

def the_number_in_the_string(filename):
    match = re.search(r'(\d+)', filename)

    if match:
        return int(match.group(0))
    else:
        return 0


print(the_number_in_the_string("file123.txt"))
print(the_number_in_the_string("no_numbers"))

#to store labels and image info
labels_dict = dict(
    img_path=[],
    xmin=[],
    xmax=[],
    ymin=[],
    ymax=[],
    img_w=[],
    img_h=[]
)
labels_dict

import os
from glob import glob

#get XML files from the annotations dir
xml_files = glob(f'{dataset_path}/annotations/*.xml')
xml_files

import xml.etree.ElementTree as xet
import cv2
for key, value in labels_dict.items():
    print(f'Length of {key}: {len(value)}')

# Process each XML file, sorted by the numerical value in the filename
for filename in sorted(xml_files, key=the_number_in_the_string):

    info = xet.parse(filename)
    root = info.getroot()

 # Finding BB info
    member_object = root.find('object')
    labels_info = member_object.find('bndbox')
    xmin = int(labels_info.find('xmin').text)
    xmax = int(labels_info.find('xmax').text)
    ymin = int(labels_info.find('ymin').text)
    ymax = int(labels_info.find('ymax').text)

# join full path
    img_name = root.find('filename').text
    img_path = os.path.join(dataset_path, 'images', img_name)

# add to dictionary
    labels_dict['img_path'].append(img_path)
    labels_dict['xmin'].append(xmin)
    labels_dict['xmax'].append(xmax)
    labels_dict['ymin'].append(ymin)
    labels_dict['ymax'].append(ymax)

# Read img and get dimensions
    height, width, _ = cv2.imread(img_path).shape
    labels_dict['img_w'].append(width)
    labels_dict['img_h'].append(height)

    alldata = pd.DataFrame(labels_dict)

alldata

from sklearn.model_selection import train_test_split

# train test val split
train, test = train_test_split(alldata, test_size=1/10, random_state=42)
train, val = train_test_split(train, train_size=8/9, random_state=42)

print(f'''
      len(train) = {len(train)}
      len(val) = {len(val)}
      len(test) = {len(test)}
''')

import shutil

# remove if exists
if os.path.exists('datasets'):
    shutil.rmtree('datasets')

train

# Function to save images in YOLO format and apply Gaussian noise
"""def make_split_folder_in_yolo_format(split_name, split_df, apply_noise=False):
    labels_path = os.path.join('datasets', 'cars_license_plate_new', split_name, 'labels')
    images_path = os.path.join('datasets', 'cars_license_plate_new', split_name, 'images')

    os.makedirs(labels_path)
    os.makedirs(images_path)

    for _, row in split_df.iterrows():
        img_name, img_extension = os.path.splitext(os.path.basename(row['img_path']))

        # Bounding box info
        x_center = (row['xmin'] + row['xmax']) / 2 / row['img_w']
        y_center = (row['ymin'] + row['ymax']) / 2 / row['img_h']
        width = (row['xmax'] - row['xmin']) / row['img_w']
        height = (row['ymax'] - row['ymin']) / row['img_h']
        # Save labels in YOLO format
        # Save labels in YOLO format
    label_path = os.path.join(labels_path, f'{img_name}.txt')
    with open(label_path, 'w') as file:
        file.write(f"0 {x_center:.4f} {y_center:.4f} {width:.4f} {height:.4f}\n")

    # Load image
    img = cv2.imread(row['img_path'])

    # If noise is applied, save in a different folder
    if apply_noise:
        # Create a separate folder for Gaussian noisy images
        gaussian_images_path = os.path.join('datasets', 'Gaussian_images', split_name, 'images')
        os.makedirs(gaussian_images_path, exist_ok=True)

        # Add Gaussian noise to the image
        img_noisy = add_gaussian_noise(img)

        # Save the noisy image in the Gaussian images folder
        cv2.imwrite(os.path.join(gaussian_images_path, img_name + img_extension), img_noisy)

    # Save the original image in the regular images folder
    cv2.imwrite(os.path.join(images_path, img_name + img_extension), img)

    print(f"Created '{images_path}', '{labels_path}', and '{gaussian_images_path}'")
"""
# Define the path in Google Drive where Gaussian images will be saved
drive_gaussian_images_path = '/content/drive/MyDrive/Gaussian_images'

# Function to make split folder in YOLO format with Gaussian noise
def make_split_folder_with_noise(split_name, split_df, apply_noise=False):
    labels_path = os.path.join(drive_gaussian_images_path, split_name, 'labels')
    images_path = os.path.join(drive_gaussian_images_path, split_name, 'images')

    os.makedirs(labels_path, exist_ok=True)
    os.makedirs(images_path, exist_ok=True)

    for _, row in split_df.iterrows():
        img_name, img_extension = os.path.splitext(os.path.basename(row['img_path']))

        x_center = (row['xmin'] + row['xmax']) / 2 / row['img_w']
        y_center = (row['ymin'] + row['ymax']) / 2 / row['img_h']
        width = (row['xmax'] - row['xmin']) / row['img_w']
        height = (row['ymax'] - row['ymin']) / row['img_h']

        # Save labels in YOLO format
        label_path = os.path.join(labels_path, f'{img_name}.txt')
        with open(label_path, 'w') as file:
            file.write(f"0 {x_center:.4f} {y_center:.4f} {width:.4f} {height:.4f}\n")

        # Load image and add Gaussian noise
        img = cv2.imread(row['img_path'])
        if apply_noise:
            img = add_gaussian_noise(img)

        # Save the noisy image
        cv2.imwrite(os.path.join(images_path, img_name + img_extension), img)

    print(f"Created '{images_path}' and '{labels_path}'")

"""# Apply the function to create noisy datasets
make_split_folder_in_yolo_format('train', train, apply_noise=True)
make_split_folder_in_yolo_format('val', val, apply_noise=True)
make_split_folder_in_yolo_format('test', test, apply_noise=True)"""
make_split_folder_with_noise('train', train, apply_noise=True)
make_split_folder_with_noise('val', val, apply_noise=True)
make_split_folder_with_noise('test', test, apply_noise=True)

os.getcwd()

image_dir = '/content/drive/MyDrive/Gaussian_images/train/images'

label_dir = '/content/drive/MyDrive/Gaussian_images/train/labels'

image_files = sorted(os.listdir(image_dir))
first_image_file = image_files[0]

# Construct paths for image and its label
image_path = os.path.join(image_dir, first_image_file)
label_path = os.path.join(label_dir, os.path.splitext(first_image_file)[0] + '.txt')

image = cv2.imread(image_path)

# Convert img BGR to OpenCV
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)


with open(label_path, 'r') as f:
    lines = f.readlines()


for line in lines:

    class_id, x_center, y_center, width, height = map(float, line.strip().split())
    img_height, img_width, _ = image.shape

# Convert YOLO format to bounding box format
    x_center *= img_width
    y_center *= img_height
    width *= img_width
    height *= img_height


    x1 = int(x_center - width / 2)
    y1 = int(y_center - height / 2)
    x2 = int(x_center + width / 2)
    y2 = int(y_center + height / 2)

    cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)


plt.imshow(image)
plt.axis('off')
plt.show()

# Datasets YAML configuration
datasets_yaml = '''
path: /content/drive/MyDrive/Gaussian_images

train: train/images
val: val/images
test: test/images

# number of classes
nc: 1

# class names
names: ['license_plate']
'''


# Write the content to the datasets.yaml file
with open('datasets.yaml', 'w') as file:
    file.write(datasets_yaml)

# using YOLOv8 nano
from ultralytics import YOLO
model = YOLO('yolov8n.pt')

os.environ['WANDB_MODE'] = 'offline'

# Define the folder where the results will be saved in Google Drive
drive_results_path = '/content/drive/MyDrive/Gaussian_images/yolo_training_results'
# Train the model with noisy images and save results to Google Drive
model.train(
    data='datasets.yaml',
    epochs=100,
    batch=16,
    device='cuda',
    imgsz=320,  # Image size (width and height) for training
    cache=True,
    project=drive_results_path,  # Specify the project path in Drive
    name='noisy_model_results',  # Specify the name of the training run
)

# Get the path of the log directory in Google Drive
log_dir = max(glob(f'{drive_results_path}/noisy_model_results*'), key=os.path.getctime)

# Read the training results from the saved CSV in Google Drive
results_csv_path = os.path.join(log_dir, 'results.csv')
results = pd.read_csv(results_csv_path)
results.columns = results.columns.str.strip()

# Extract epochs and mAP metrics
epochs = results.index + 1
mAP_0_5 = results['metrics/mAP50(B)']
mAP_0_5_0_95 = results['metrics/mAP50-95(B)']

# Plot the results
plt.figure(figsize=(10, 5))
plt.plot(epochs, mAP_0_5, label='mAP@0.5')
plt.plot(epochs, mAP_0_5_0_95, label='mAP@0.5:0.95')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.title('Accuracy Over Epochs')
plt.legend()
plt.grid(True)
plt.show()

# Save the trained model in Google Drive
model.save('/content/drive/MyDrive/Gaussian_images/license_plate_model_with_gaussian_noise.pt')

# to predict test image
def predict_and_plot(path_test_car):

    results = model.predict(path_test_car, device='cpu')


    image = cv2.imread(path_test_car)

    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)


    for result in results:
        for box in result.boxes:

            x1, y1, x2, y2 = map(int, box.xyxy[0])
            confidence = box.conf[0]

            cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)

            cv2.putText(image, f'{confidence*100:.2f}%', (x1, y1 - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)


    plt.imshow(image)
    plt.axis('off')
    plt.show()

predict_and_plot('/content/drive/MyDrive/Gaussian_images/val/images/Cars0.png')

predict_and_plot('/content/drive/MyDrive/Gaussian_images/val/images/Cars106.png')

predict_and_plot('/content/drive/MyDrive/Gaussian_images/val/images/Cars172.png')

predict_and_plot('/content/drive/MyDrive/Gaussian_images/val/images/Cars246.png')

'''from ultralytics import YOLO

# Load the trained model (assuming the model is already trained and saved)
model = YOLO('/content/drive/MyDrive/Gaussian_images/license_plate_model_with_gaussian_noise.pt')

# Evaluate on the test set
metrics = model.val(data='datasets.yaml', split='test')

# Print evaluation results
print(f"mAP@0.5: {metrics['metrics/mAP50(B)']:.4f}")
print(f"mAP@0.5:0.95: {metrics['metrics/mAP50-95(B)']:.4f}")
print(f"Precision: {metrics['metrics/precision(B)']:.4f}")
print(f"Recall: {metrics['metrics/recall(B)']:.4f}")
print(f"F1-score: {metrics['metrics/F1-score(B)']:.4f}")'''
import matplotlib.pyplot as plt
import pandas as pd
from glob import glob
import os

# Load the training log to get mAP values for different epochs
log_dir = max(glob('/content/drive/MyDrive/Gaussian_images/runs/detect/train*'), key=os.path.getctime)
results = pd.read_csv(os.path.join(log_dir, 'results.csv'))

# Extracting the data
epochs = results.index + 1
mAP_0_5 = results['metrics/mAP50(B)']
mAP_0_5_0_95 = results['metrics/mAP50-95(B)']

# Plot the mAP over the epochs
plt.figure(figsize=(10, 6))
plt.plot(epochs, mAP_0_5, label='mAP@0.5')
plt.plot(epochs, mAP_0_5_0_95, label='mAP@0.5:0.95')
plt.xlabel('Epochs')
plt.ylabel('Mean Average Precision (mAP)')
plt.title('Model Performance over Epochs')
plt.legend()
plt.grid(True)
plt.show()

